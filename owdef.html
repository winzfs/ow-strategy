<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Ïö¥Îπ®ÏõπÏ°¥ÎßéÍ≤ú: ÎÑ§Ïò® Î¶¨Î≥∏</title>
    <style>
        :root { --p: #00f2ff; --s: #7000ff; --d: #ff0055; --bg: #050505; }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #000; overflow: hidden; display: flex; justify-content: center; align-items: center; }
        
        #game-container {
            position: relative; width: 100vw; height: 100vh; max-width: 500px; max-height: 900px;
            background: var(--bg); overflow: hidden; display: flex; flex-direction: column;
            border: 2px solid #1a1a1a;
        }

        canvas { display: block; width: 100%; height: 100%; touch-action: none; }

        /* UI Î†àÏù¥Ïñ¥ - ÎÑ§Ïò® Ïä§ÌÉÄÏùº */
        #ui-header { 
            position: absolute; top: 30px; left: 0; width: 100%; 
            display: flex; justify-content: space-around; pointer-events: none; z-index: 10;
        }
        .stat-box { 
            background: rgba(255, 255, 255, 0.05); padding: 8px 15px; border-radius: 12px; 
            border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(5px);
            min-width: 80px; text-align: center;
        }
        .stat-label { font-size: 9px; color: #888; letter-spacing: 1px; }
        .stat-value { font-size: 18px; font-weight: 900; font-family: 'Arial Black', sans-serif; }

        /* ÌôîÎ©¥ Ï†ÑÌôò Ìö®Í≥º */
        .screen { 
            position: absolute; inset: 0; background: rgba(0,0,0,0.95); 
            display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100;
        }
        h1 { 
            color: var(--p); font-size: 42px; font-family: 'Arial Black'; 
            text-shadow: 0 0 20px var(--p); margin-bottom: 40px; text-align: center;
        }
        .btn-main { 
            padding: 20px 60px; background: linear-gradient(45deg, var(--s), var(--p));
            border: none; color: white; border-radius: 15px; font-size: 22px; font-weight: bold;
            cursor: pointer; transition: 0.2s; box-shadow: 0 0 20px rgba(0, 242, 255, 0.4);
        }
        .btn-main:active { transform: scale(0.95); }
        
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="ui-header" class="hidden">
            <div class="stat-box" style="border-bottom: 2px solid var(--p)">
                <div class="stat-label">GOLD</div>
                <div class="stat-value" style="color:var(--p)" id="gold-val">100</div>
            </div>
            <div class="stat-box" style="border-bottom: 2px solid var(--d)">
                <div class="stat-label">LIFE</div>
                <div class="stat-value" style="color:var(--d)" id="life-val">50</div>
            </div>
            <div class="stat-box" style="border-bottom: 2px solid #fff">
                <div class="stat-label">WAVE</div>
                <div class="stat-value" id="wave-val">1</div>
            </div>
        </div>

        <canvas id="gameCanvas"></canvas>

        <div id="start-screen" class="screen">
            <h1>LUCKY<br><span style="color:#fff">DEFENSE</span></h1>
            <button class="btn-main" onclick="startGame()">START GAME</button>
        </div>

        <div id="over-screen" class="screen hidden">
            <h1 style="color:var(--d)">GAME OVER</h1>
            <button class="btn-main" onclick="location.reload()">RETRY</button>
        </div>
    </div>

<script>
/** üë®‚Äçüíª Ï†ÑÎ¨∏Í∞Ä ÌåÄÏùò ÌÜµÌï© Í≤åÏûÑ ÏóîÏßÑ **/
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const container = document.getElementById('game-container');

let gold = 100, wave = 1, life = 50;
let monsters = [], board = Array(16).fill(null), particles = [];
let gameState = 'START', spawnTimer = 0, lastTime = 0;
let dragIdx = null, mx = 0, my = 0;

const GRADES = [
    { name: 'COMMON', color: '#ffffff', power: 4, glow: '#fff' },
    { name: 'RARE', color: '#00f2ff', power: 10, glow: '#00f2ff' },
    { name: 'EPIC', color: '#7000ff', power: 25, glow: '#7000ff' },
    { name: 'LEGEND', color: '#ff0055', power: 60, glow: '#ff0055' }
];

let TILE_SIZE, BOARD_X, BOARD_Y, PATH;

function initLayout() {
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
    TILE_SIZE = Math.min(canvas.width / 4.6, 95);
    BOARD_X = (canvas.width - (TILE_SIZE * 4)) / 2;
    BOARD_Y = canvas.height * 0.42;
    
    // üõ†Ô∏è Í∏∞ÌöçÏûê: Î≥¥ÎìúÌåê Ï£ºÎ≥ÄÏùÑ ÏôÑÏ†ÑÌûà Í∞êÏã∏Îäî ÌöåÏ†Ñ Í≤ΩÎ°ú
    const offset = 40;
    const pTop = BOARD_Y - offset;
    const pBtm = BOARD_Y + (TILE_SIZE * 4) + offset;
    const pLeft = BOARD_X - offset;
    const pRight = BOARD_X + (TILE_SIZE * 4) + offset;

    PATH = [
        {x1: pLeft, y1: pTop, x2: pRight, y2: pTop}, // ÏÉÅ
        {x1: pRight, y1: pTop, x2: pRight, y2: pBtm}, // Ïö∞
        {x1: pRight, y1: pBtm, x2: pLeft, y2: pBtm}, // Ìïò
        {x1: pLeft, y1: pBtm, x2: pLeft, y2: pTop}  // Ï¢å
    ];
}

window.addEventListener('resize', initLayout);
initLayout();

function startGame() {
    gameState = 'PLAY';
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('ui-header').classList.remove('hidden');
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
}

function gameLoop(time) {
    if (gameState !== 'PLAY') return;
    const dt = time - lastTime;
    lastTime = time;

    // Î∞∞Í≤Ω Î†åÎçîÎßÅ
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // 1. Î™¨Ïä§ÌÑ∞ Î°úÏßÅ (ÌöåÏ†Ñ Í≤ΩÎ°ú)
    spawnTimer += dt;
    if (spawnTimer > Math.max(400, 2000 - (wave * 150))) {
        monsters.push({
            x: PATH[0].x1, y: PATH[0].y1, pathIdx: 0,
            hp: 25 * wave, maxHp: 25 * wave, speed: 1.5 + (wave*0.1)
        });
        spawnTimer = 0;
    }

    monsters.forEach((m, i) => {
        const p = PATH[m.pathIdx];
        const dx = p.x2 - p.x1, dy = p.y2 - p.y1;
        const len = Math.sqrt(dx*dx + dy*dy);
        m.x += (dx/len) * m.speed; m.y += (dy/len) * m.speed;

        if (Math.hypot(m.x - p.x2, m.y - p.y2) < 5) {
            m.pathIdx++;
            if (m.pathIdx >= PATH.length) {
                life--; monsters.splice(i, 1); return;
            }
            m.x = PATH[m.pathIdx].x1; m.y = PATH[m.pathIdx].y1;
        }

        // Î™¨Ïä§ÌÑ∞ ÎîîÏûêÏù∏
        ctx.shadowBlur = 10; ctx.shadowColor = 'red';
        ctx.fillStyle = '#ff0055';
        ctx.beginPath(); ctx.arc(m.x, m.y, 10, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#222'; ctx.fillRect(m.x-12, m.y-20, 24, 4);
        ctx.fillStyle = '#ff0055'; ctx.fillRect(m.x-12, m.y-20, (m.hp/m.maxHp)*24, 4);
    });

    // 2. Î≥¥ÎìúÌåê Î†åÎçîÎßÅ
    for (let i = 0; i < 16; i++) {
        const bx = BOARD_X + (i % 4) * TILE_SIZE;
        const by = BOARD_Y + Math.floor(i / 4) * TILE_SIZE;
        
        ctx.strokeStyle = '#1a1a1a';
        ctx.lineWidth = 1;
        ctx.strokeRect(bx + 4, by + 4, TILE_SIZE - 8, TILE_SIZE - 8);

        if (board[i] && dragIdx !== i) {
            // Ïú†Îãõ ÏïÑÏù¥Îì§ Ïï†ÎãàÎ©îÏù¥ÏÖò (Í∏∞Ïö∏Í∏∞ Ìö®Í≥º)
            const tilt = Math.sin(time / 200) * 0.05;
            drawUnit(board[i], bx + TILE_SIZE/2, by + TILE_SIZE/2, false, tilt);
            updateAttack(board[i], bx + TILE_SIZE/2, by + TILE_SIZE/2, dt);
        }
    }

    if (dragIdx !== null) drawUnit(board[dragIdx], mx, my, true);

    // 3. ÌååÌã∞ÌÅ¥ & UI
    updateParticles();
    document.getElementById('gold-val').innerText = gold;
    document.getElementById('life-val').innerText = life;
    document.getElementById('wave-val').innerText = wave;

    // üõ†Ô∏è ÏÜåÌôò Î≤ÑÌäº (ÌôîÎ©¥ ÌïòÎã®)
    const btnY = canvas.height - 120;
    const btnH = 70;
    const grad = ctx.createLinearGradient(0, btnY, 0, btnY+btnH);
    grad.addColorStop(0, gold >= 10 ? '#7000ff' : '#222');
    grad.addColorStop(1, gold >= 10 ? '#00f2ff' : '#111');
    
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.roundRect(40, btnY, canvas.width - 80, btnH, 20); ctx.fill();
    ctx.fillStyle = '#fff'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'center';
    ctx.fillText("SUMMON UNIT (10G)", canvas.width/2, btnY + 42);

    if (life <= 0) endGame();
    else {
        if (time % 20000 < 20) wave++;
        requestAnimationFrame(gameLoop);
    }
}

function drawUnit(u, x, y, isDrag = false, tilt = 0) {
    const g = GRADES[u.grade];
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(tilt);
    
    ctx.shadowBlur = isDrag ? 25 : 15;
    ctx.shadowColor = g.glow;
    ctx.fillStyle = g.color;
    ctx.beginPath(); ctx.arc(0, 0, TILE_SIZE/3, 0, Math.PI*2); ctx.fill();
    
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#000'; ctx.font = '900 12px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText(u.name[0], 0, 5); // Ïù¥Î¶Ñ Ï≤´Í∏ÄÏûêÎßå ÌëúÍ∏∞Ìï¥ Ïã¨ÌîåÌïòÍ≤å
    ctx.restore();
}

function updateAttack(u, ux, uy, dt) {
    u.timer = (u.timer || 0) + dt;
    if (u.timer > (1000 - u.grade*200) && monsters.length > 0) {
        let target = null;
        for(let m of monsters) {
            if(Math.hypot(m.x - ux, m.y - uy) < 220) { target = m; break; }
        }
        if (target) {
            u.timer = 0;
            ctx.strokeStyle = GRADES[u.grade].color; ctx.lineWidth = 3;
            ctx.shadowBlur = 10; ctx.shadowColor = GRADES[u.grade].color;
            ctx.beginPath(); ctx.moveTo(ux, uy); ctx.lineTo(target.x, target.y); ctx.stroke();
            ctx.shadowBlur = 0;
            target.hp -= GRADES[u.grade].power;
            if (target.hp <= 0) {
                gold += 2; createExplosion(target.x, target.y, GRADES[u.grade].color);
                monsters.splice(monsters.indexOf(target), 1);
            }
        }
    }
}

function handleStart(e) {
    const rect = canvas.getBoundingClientRect();
    const cx = e.touches ? e.touches[0].clientX : e.clientX;
    const cy = e.touches ? e.touches[0].clientY : e.clientY;
    mx = cx - rect.left; my = cy - rect.top;

    if (my > canvas.height - 130) { spawnUnit(); return; }
    for (let i = 0; i < 16; i++) {
        const bx = BOARD_X + (i % 4) * TILE_SIZE, by = BOARD_Y + Math.floor(i / 4) * TILE_SIZE;
        if (mx > bx && mx < bx + TILE_SIZE && my > by && my < by + TILE_SIZE) {
            if (board[i]) dragIdx = i;
        }
    }
}

function handleMove(e) {
    const rect = canvas.getBoundingClientRect();
    const cx = e.touches ? e.touches[0].clientX : e.clientX;
    const cy = e.touches ? e.touches[0].clientY : e.clientY;
    mx = cx - rect.left; my = cy - rect.top;
}

function handleEnd() {
    if (dragIdx === null) return;
    let targetIdx = -1;
    for (let i = 0; i < 16; i++) {
        const bx = BOARD_X + (i % 4) * TILE_SIZE, by = BOARD_Y + Math.floor(i / 4) * TILE_SIZE;
        if (mx > bx && mx < bx + TILE_SIZE && my > by && my < by + TILE_SIZE) targetIdx = i;
    }
    if (targetIdx !== -1 && targetIdx !== dragIdx) {
        const a = board[dragIdx], b = board[targetIdx];
        if (b && a.name === b.name && a.grade === b.grade && a.grade < 3) {
            board[targetIdx] = { ...a, grade: a.grade + 1, timer: 0 };
            board[dragIdx] = null;
            createExplosion(mx, my, GRADES[a.grade+1].color, 30);
        } else {
            board[dragIdx] = b; board[targetIdx] = a;
        }
    }
    dragIdx = null;
}

function spawnUnit() {
    const empty = board.map((v, i) => v === null ? i : null).filter(v => v !== null);
    if (empty.length > 0 && gold >= 10) {
        gold -= 10;
        const idx = empty[Math.floor(Math.random() * empty.length)];
        const names = ['KNIGHT', 'ARCHER', 'MAGE', 'ROGUE'];
        board[idx] = { name: names[Math.floor(Math.random()*4)], grade: 0, timer: 0 };
        createExplosion(BOARD_X + (idx%4)*TILE_SIZE + TILE_SIZE/2, BOARD_Y + Math.floor(idx/4)*TILE_SIZE + TILE_SIZE/2, '#fff', 20);
    }
}

function createExplosion(x, y, color, count = 15) {
    for(let i=0; i<count; i++) particles.push({ x, y, color, vx:(Math.random()-0.5)*12, vy:(Math.random()-0.5)*12, life:1 });
}
function updateParticles() {
    particles.forEach(p => {
        p.x += p.vx; p.y += p.vy; p.life -= 0.03;
        ctx.fillStyle = p.color; ctx.globalAlpha = p.life;
        ctx.fillRect(p.x, p.y, 4, 4);
    });
    particles = particles.filter(p => p.life > 0); ctx.globalAlpha = 1;
}

function endGame() {
    gameState = 'OVER';
    document.getElementById('over-screen').classList.remove('hidden');
}

canvas.addEventListener('mousedown', handleStart);
window.addEventListener('mousemove', handleMove);
window.addEventListener('mouseup', handleEnd);
canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleStart(e); }, {passive:false});
window.addEventListener('touchmove', (e) => { e.preventDefault(); handleMove(e); }, {passive:false});
window.addEventListener('touchend', handleEnd);
</script>
</body>
</html>
