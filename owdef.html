<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ìš´ë¹¨ì›¹ì¡´ë§ê²œ: ë¨¸ì§€ ë§ˆìŠ¤í„°</title>
    <style>
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { margin: 0; padding: 0; background: #000; color: #fff; font-family: 'Arial', sans-serif; overflow: hidden; touch-action: none; display: flex; justify-content: center; align-items: center; height: 100vh; width: 100vw; }
        
        /* ğŸ› ï¸ ì—”ì§€ë‹ˆì–´: í™”ë©´ ê³ ì • ë ˆì´ì•„ì›ƒ */
        #game-wrapper { position: relative; width: 100%; height: 100%; max-width: 500px; max-height: 900px; background: #111; overflow: hidden; border: 2px solid #333; }
        canvas { display: block; width: 100%; height: 100%; }
        
        #ui-layer { position: absolute; top: 15px; left: 15px; pointer-events: none; z-index: 10; text-shadow: 2px 2px 2px #000; }
        .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; }
        h1 { color: #f1c40f; font-size: 28px; margin-bottom: 20px; text-align: center; }
        .btn { padding: 15px 40px; background: #e74c3c; border: none; color: white; border-radius: 50px; font-size: 18px; font-weight: bold; cursor: pointer; }
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="game-wrapper">
        <div id="ui-layer" class="hidden">
            <div style="color:#f1c40f; font-size: 20px;">ğŸ’° <span id="gold-val">100</span></div>
            <div style="color:#3498db">ğŸŒŠ WAVE <span id="wave-val">1</span></div>
            <div style="color:#ff4d4d">ğŸ‘¾ MOBS <span id="mob-val">0</span>/50</div>
        </div>

        <canvas id="gameCanvas"></canvas>

        <div id="start-screen" class="screen">
            <h1>ìš´ë¹¨ì›¹ì¡´ë§ê²œ<br>MERGE DEFENSE</h1>
            <button class="btn" onclick="startGame()">ì „íˆ¬ ì‹œì‘</button>
        </div>

        <div id="over-screen" class="screen hidden">
            <h1 style="color:#e74c3c">GAME OVER</h1>
            <button class="btn" onclick="location.reload()">ë‹¤ì‹œ ë„ì „</button>
        </div>
    </div>

<script>
/** ğŸ‘¨â€ğŸ’» í”„ë¡œê·¸ë˜ë¨¸: ê³ ì„±ëŠ¥ í„°ì¹˜ & í•©ì„± ë¡œì§ **/
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const wrapper = document.getElementById('game-wrapper');

let gold = 100;
let wave = 1;
let monsters = [];
let board = Array(16).fill(null);
let gameState = 'START';
let particles = [];
let spawnTimer = 0;
let lastTime = 0;

// ë“œë˜ê·¸ ìƒíƒœ
let dragIdx = null;
let mx = 0, my = 0; // ë§ˆìš°ìŠ¤/í„°ì¹˜ í˜„ì¬ ì¢Œí‘œ

const GRADES = [
    { name: 'ì¼ë°˜', color: '#ffffff' },
    { name: 'í¬ê·€', color: '#3498db' },
    { name: 'ì˜ì›…', color: '#9b59b6' },
    { name: 'ì „ì„¤', color: '#f1c40f' }
];

const UNIT_TYPES = ['ê²€ì‚¬', 'ê¶ìˆ˜', 'ë²•ì‚¬', 'ë„ì '];

// ë°°ì¹˜ ì„¤ì •
let TILE_SIZE, BOARD_X, BOARD_Y;

function resize() {
    canvas.width = wrapper.clientWidth;
    canvas.height = wrapper.clientHeight;
    TILE_SIZE = Math.min(canvas.width / 4.5, 100);
    BOARD_X = (canvas.width - (TILE_SIZE * 4)) / 2;
    BOARD_Y = canvas.height * 0.45;
}
window.addEventListener('resize', resize);
resize();

// ëª¬ìŠ¤í„° ìˆœí™˜ ê²½ë¡œ ì„¤ì •
function getPath() {
    const margin = 30;
    return [
        {x1: margin, y1: 80, x2: canvas.width - margin, y2: 80},
        {x1: canvas.width - margin, y1: 80, x2: canvas.width - margin, y2: BOARD_Y - 50},
        {x1: canvas.width - margin, y1: BOARD_Y - 50, x2: margin, y2: BOARD_Y - 50},
        {x1: margin, y1: BOARD_Y - 50, x2: margin, y2: 80}
    ];
}

function startGame() {
    gameState = 'PLAY';
    document.querySelector('.screen').classList.add('hidden');
    document.getElementById('ui-layer').classList.remove('hidden');
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
}

function gameLoop(time) {
    if (gameState !== 'PLAY') return;
    const dt = time - lastTime;
    lastTime = time;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const path = getPath();

    // 1. ëª¬ìŠ¤í„° ìƒì„± ë° ì´ë™
    spawnTimer += dt;
    if (spawnTimer > 1800) {
        monsters.push({
            x: path[0].x1, y: path[0].y1, pathIdx: 0,
            hp: 15 * wave, maxHp: 15 * wave, speed: 1.5 + (wave * 0.1)
        });
        spawnTimer = 0;
    }

    monsters.forEach((m, i) => {
        let p = path[m.pathIdx];
        let dx = p.x2 - p.x1, dy = p.y2 - p.y1;
        let len = Math.sqrt(dx*dx + dy*dy);
        m.x += (dx/len) * m.speed; m.y += (dy/len) * m.speed;

        if (Math.hypot(m.x - p.x2, m.y - p.y2) < 5) {
            m.pathIdx = (m.pathIdx + 1) % path.length;
            m.x = path[m.pathIdx].x1; m.y = path[m.pathIdx].y1;
        }

        ctx.fillStyle = '#ff4d4d';
        ctx.fillRect(m.x-12, m.y-12, 24, 24);
        ctx.fillStyle = '#0f0';
        ctx.fillRect(m.x-12, m.y-20, (m.hp/m.maxHp)*24, 4);
    });

    // 2. ë³´ë“œíŒ ê·¸ë¦¬ê¸°
    for (let i = 0; i < 16; i++) {
        const bx = BOARD_X + (i % 4) * TILE_SIZE;
        const by = BOARD_Y + Math.floor(i / 4) * TILE_SIZE;
        
        ctx.strokeStyle = '#333';
        ctx.strokeRect(bx + 2, by + 2, TILE_SIZE - 4, TILE_SIZE - 4);

        if (board[i] && dragIdx !== i) {
            drawUnit(board[i], bx + TILE_SIZE/2, by + TILE_SIZE/2);
            attackTarget(board[i], bx + TILE_SIZE/2, by + TILE_SIZE/2, dt);
        }
    }

    // 3. ë“œë˜ê·¸ ì¤‘ì¸ ìœ ë‹› (ë§ˆìš°ìŠ¤ ìœ„ì¹˜ì— ë”°ë¼ ê·¸ë¦¬ê¸°)
    if (dragIdx !== null) {
        ctx.save();
        ctx.globalAlpha = 0.8;
        drawUnit(board[dragIdx], mx, my);
        ctx.restore();
    }

    // 4. ì´í™íŠ¸ ë° UI
    particles.forEach((p, i) => {
        p.x += p.vx; p.y += p.vy; p.life -= 0.03;
        ctx.fillStyle = p.color; ctx.globalAlpha = p.life;
        ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill();
    });
    particles = particles.filter(p => p.life > 0); ctx.globalAlpha = 1;

    document.getElementById('gold-val').innerText = gold;
    document.getElementById('wave-val').innerText = wave;
    document.getElementById('mob-val').innerText = monsters.length;

    // ì†Œí™˜ ë²„íŠ¼
    const btnY = canvas.height - 80;
    ctx.fillStyle = '#222';
    ctx.roundRect(40, btnY, canvas.width - 80, 50, 25); ctx.fill();
    ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.font = 'bold 16px Arial';
    ctx.fillText("ëœë¤ ì†Œí™˜ (10G)", canvas.width/2, btnY + 32);

    if (monsters.length >= 50) endGame();
    else requestAnimationFrame(gameLoop);
}

function drawUnit(u, x, y) {
    const gradeInfo = GRADES[u.grade];
    ctx.fillStyle = gradeInfo.color;
    ctx.beginPath(); ctx.arc(x, y, TILE_SIZE/2.8, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#000'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center';
    ctx.fillText(u.name, x, y - 2);
    ctx.font = '9px Arial';
    ctx.fillText(gradeInfo.name, x, y + 10);
}

function attackTarget(u, ux, uy, dt) {
    u.timer = (u.timer || 0) + dt;
    const speed = 1000 - (u.grade * 150);
    if (u.timer > speed && monsters.length > 0) {
        const target = monsters[0];
        if (Math.hypot(target.x - ux, target.y - uy) < 200) {
            u.timer = 0;
            ctx.strokeStyle = GRADES[u.grade].color;
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(ux, uy); ctx.lineTo(target.x, target.y); ctx.stroke();
            target.hp -= (u.grade + 1) * 3;
            if (target.hp <= 0) { monsters.shift(); gold += 2; }
        }
    }
}

// ğŸ› ï¸ í”„ë¡œê·¸ë˜ë¨¸: ì •í™•í•œ í„°ì¹˜ ì¢Œí‘œ ê³„ì‚°ê¸°
function updatePointer(e) {
    const rect = canvas.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    mx = clientX - rect.left;
    my = clientY - rect.top;
}

function onStart(e) {
    updatePointer(e);
    // ì†Œí™˜ ë²„íŠ¼ ì²´í¬
    if (my > canvas.height - 100) { spawnUnit(); return; }

    // ë³´ë“œ ìœ ë‹› ì²´í¬
    for (let i = 0; i < 16; i++) {
        const bx = BOARD_X + (i % 4) * TILE_SIZE;
        const by = BOARD_Y + Math.floor(i / 4) * TILE_SIZE;
        if (mx > bx && mx < bx + TILE_SIZE && my > by && my < by + TILE_SIZE) {
            if (board[i]) dragIdx = i;
        }
    }
}

function onEnd() {
    if (dragIdx === null) return;
    
    let dropIdx = -1;
    for (let i = 0; i < 16; i++) {
        const bx = BOARD_X + (i % 4) * TILE_SIZE;
        const by = BOARD_Y + Math.floor(i / 4) * TILE_SIZE;
        if (mx > bx && mx < bx + TILE_SIZE && my > by && my < by + TILE_SIZE) dropIdx = i;
    }

    if (dropIdx !== -1 && dropIdx !== dragIdx) {
        const uA = board[dragIdx];
        const uB = board[dropIdx];

        // ğŸ“ ê¸°íšì: í•©ì„± ë¡œì§ ì ìš©
        if (uB && uA.name === uB.name && uA.grade === uB.grade && uA.grade < 3) {
            board[dropIdx] = { ...uA, grade: uA.grade + 1, timer: 0 };
            board[dragIdx] = null;
            createEffect(mx, my, GRADES[uA.grade + 1].color);
        } else {
            // ìœ„ì¹˜ êµí™˜
            board[dragIdx] = uB;
            board[dropIdx] = uA;
        }
    }
    dragIdx = null;
}

function spawnUnit() {
    const empty = board.map((v, i) => v === null ? i : null).filter(v => v !== null);
    if (empty.length > 0 && gold >= 10) {
        gold -= 10;
        const idx = empty[Math.floor(Math.random() * empty.length)];
        board[idx] = { name: UNIT_TYPES[Math.floor(Math.random() * 4)], grade: 0, timer: 0 };
    }
}

function createEffect(x, y, color) {
    for(let i=0; i<20; i++) {
        particles.push({ x, y, color, vx: (Math.random()-0.5)*15, vy: (Math.random()-0.5)*15, life: 1 });
    }
}

function endGame() {
    gameState = 'OVER';
    document.getElementById('over-screen').classList.remove('hidden');
}

canvas.addEventListener('mousedown', onStart);
window.addEventListener('mousemove', updatePointer);
window.addEventListener('mouseup', onEnd);
canvas.addEventListener('touchstart', (e) => { e.preventDefault(); onStart(e); }, {passive: false});
window.addEventListener('touchmove', (e) => { e.preventDefault(); updatePointer(e); }, {passive: false});
window.addEventListener('touchend', onEnd);

</script>
</body>
</html>
