<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ìš´ë¹¨ì›¹ì¡´ë§ê²œ: ìµœì í™” ë²„ì „</title>
    <style>
        /* ğŸ› ï¸ ì—”ì§€ë‹ˆì–´: ëª¨ë°”ì¼ ë·°í¬íŠ¸ ë° ê³ ì • ë ˆì´ì•„ì›ƒ ìˆ˜ì • */
        :root { --primary: #f1c40f; --danger: #e74c3c; --bg: #0a0a0a; }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #000; overflow: hidden; display: flex; justify-content: center; align-items: center; }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            max-width: 500px;
            max-height: 900px;
            background: var(--bg);
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
        }

        canvas { display: block; width: 100%; height: 100%; touch-action: none; }

        /* UI ë ˆì´ì–´ */
        #ui-header { position: absolute; top: 20px; left: 0; width: 100%; display: flex; justify-content: space-around; pointer-events: none; z-index: 10; }
        .stat-box { background: rgba(0,0,0,0.6); padding: 5px 15px; border-radius: 15px; border: 1px solid #333; text-align: center; }
        .stat-label { font-size: 10px; color: #aaa; margin-bottom: 2px; }
        .stat-value { font-size: 18px; font-weight: bold; font-family: 'Courier New', monospace; }

        .screen { position: absolute; inset: 0; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; text-align: center; }
        h1 { color: var(--primary); font-size: 32px; text-shadow: 0 0 15px var(--primary); margin-bottom: 30px; line-height: 1.2; }
        .btn { padding: 18px 50px; background: var(--danger); border: none; color: white; border-radius: 50px; font-size: 20px; font-weight: bold; cursor: pointer; box-shadow: 0 5px 0 #c0392b; transition: 0.1s; }
        .btn:active { transform: translateY(3px); box-shadow: 0 2px 0 #c0392b; }
        
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="ui-header" class="hidden">
            <div class="stat-box">
                <div class="stat-label">GOLD</div>
                <div class="stat-value" style="color:var(--primary)" id="gold-val">100</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">LIFE</div>
                <div class="stat-value" style="color:var(--danger)" id="life-val">50</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">WAVE</div>
                <div class="stat-value" id="wave-val">1</div>
            </div>
        </div>

        <canvas id="gameCanvas"></canvas>

        <div id="start-screen" class="screen">
            <h1>ìš´ë¹¨ì›¹ì¡´ë§ê²œ<br><span style="font-size:18px; color:#fff;">LUCKY WEB DEFENSE</span></h1>
            <button class="btn" onclick="startGame()">ì „íˆ¬ ì‹œì‘</button>
        </div>

        <div id="over-screen" class="screen hidden">
            <h1 style="color:var(--danger)">DEFEAT</h1>
            <p id="final-stats" style="color:#ccc; margin-bottom:20px;"></p>
            <button class="btn" onclick="location.reload()">ë‹¤ì‹œ ì‹œì‘</button>
        </div>
    </div>

<script>
/** ğŸ‘¨â€ğŸ’» í”„ë¡œê·¸ë˜ë¨¸: í™”ë©´ ë™ê¸°í™” ë° ë¬¼ë¦¬ ì—”ì§„ ë¡œì§ **/
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const container = document.getElementById('game-container');

let gold = 100, wave = 1, life = 50;
let monsters = [], board = Array(16).fill(null), particles = [];
let gameState = 'START', spawnTimer = 0, lastTime = 0;
let dragIdx = null, mx = 0, my = 0;

const GRADES = [
    { name: 'ì¼ë°˜', color: '#FFFFFF', power: 3 },
    { name: 'í¬ê·€', color: '#3498db', power: 7 },
    { name: 'ì˜ì›…', color: '#9b59b6', power: 15 },
    { name: 'ì „ì„¤', color: '#f1c40f', power: 35 }
];
const UNIT_NAMES = ['ê²€ì‚¬', 'ê¶ìˆ˜', 'ë²•ì‚¬', 'ë„ì '];

let TILE_SIZE, BOARD_X, BOARD_Y, PATH;

function initLayout() {
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
    TILE_SIZE = Math.min(canvas.width / 4.6, 90);
    BOARD_X = (canvas.width - (TILE_SIZE * 4)) / 2;
    BOARD_Y = canvas.height * 0.48;
    
    const m = 25;
    const pathBtm = BOARD_Y - 40;
    PATH = [
        {x1: m, y1: 100, x2: canvas.width - m, y2: 100},
        {x1: canvas.width - m, y1: 100, x2: canvas.width - m, y2: pathBtm},
        {x1: canvas.width - m, y1: pathBtm, x2: m, y2: pathBtm},
        {x1: m, y1: pathBtm, x2: m, y2: 100}
    ];
}

window.addEventListener('resize', initLayout);
initLayout();

function startGame() {
    gameState = 'PLAY';
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('ui-header').classList.remove('hidden');
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
}

function gameLoop(time) {
    if (gameState !== 'PLAY') return;
    const dt = time - lastTime;
    lastTime = time;

    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // 1. ëª¬ìŠ¤í„° ë¡œì§
    spawnTimer += dt;
    if (spawnTimer > Math.max(500, 2000 - (wave * 100))) {
        monsters.push({ x: PATH[0].x1, y: PATH[0].y1, pathIdx: 0, hp: 20 * wave, maxHp: 20 * wave, speed: 1.2 + (wave*0.1) });
        spawnTimer = 0;
    }

    monsters.forEach((m, i) => {
        const p = PATH[m.pathIdx];
        const dx = p.x2 - p.x1, dy = p.y2 - p.y1;
        const len = Math.sqrt(dx*dx + dy*dy);
        m.x += (dx/len) * m.speed; m.y += (dy/len) * m.speed;

        if (Math.hypot(m.x - p.x2, m.y - p.y2) < 5) {
            m.pathIdx++;
            if (m.pathIdx >= PATH.length) { // í•œ ë°”í€´ ì™„ì£¼
                life--;
                monsters.splice(i, 1);
                return;
            }
            m.x = PATH[m.pathIdx].x1; m.y = PATH[m.pathIdx].y1;
        }

        ctx.fillStyle = '#ff4d4d';
        ctx.beginPath(); ctx.arc(m.x, m.y, 10, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#0f0';
        ctx.fillRect(m.x-10, m.y-18, (m.hp/m.maxHp)*20, 3);
    });

    // 2. ë³´ë“œíŒ & ìœ ë‹›
    for (let i = 0; i < 16; i++) {
        const bx = BOARD_X + (i % 4) * TILE_SIZE;
        const by = BOARD_Y + Math.floor(i / 4) * TILE_SIZE;
        
        ctx.strokeStyle = (dragIdx !== null) ? '#444' : '#222';
        ctx.lineWidth = 2;
        ctx.strokeRect(bx + 3, by + 3, TILE_SIZE - 6, TILE_SIZE - 6);

        if (board[i] && dragIdx !== i) {
            drawUnit(board[i], bx + TILE_SIZE/2, by + TILE_SIZE/2);
            updateAttack(board[i], bx + TILE_SIZE/2, by + TILE_SIZE/2, dt);
        }
    }

    if (dragIdx !== null) drawUnit(board[dragIdx], mx, my, true);

    // 3. ì´í™íŠ¸ ë° ìŠ¤íƒ¯ ê°±ì‹ 
    updateParticles();
    document.getElementById('gold-val').innerText = gold;
    document.getElementById('life-val').innerText = life;
    document.getElementById('wave-val').innerText = wave;

    // 4. ì†Œí™˜ ë²„íŠ¼ (ë””ìì¸ ë³´ê°•)
    const btnY = canvas.height - 100;
    ctx.fillStyle = (gold >= 10) ? '#2ecc71' : '#333';
    ctx.beginPath(); ctx.roundRect(50, btnY, canvas.width - 100, 55, 27); ctx.fill();
    ctx.fillStyle = '#fff'; ctx.font = 'bold 18px Arial'; ctx.textAlign = 'center';
    ctx.fillText(`ëœë¤ ì†Œí™˜ (10G)`, canvas.width/2, btnY + 35);

    if (life <= 0) endGame();
    else {
        if (time % 30000 < 20) wave++; // 30ì´ˆë§ˆë‹¤ ì›¨ì´ë¸Œ ìƒìŠ¹
        requestAnimationFrame(gameLoop);
    }
}

function drawUnit(u, x, y, isDragging = false) {
    const g = GRADES[u.grade];
    if (isDragging) { ctx.shadowBlur = 15; ctx.shadowColor = g.color; }
    ctx.fillStyle = g.color;
    ctx.beginPath(); ctx.arc(x, y, TILE_SIZE/3, 0, Math.PI*2); ctx.fill();
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#000'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center';
    ctx.fillText(u.name, x, y - 2);
    ctx.font = '8px Arial'; ctx.fillText(g.name, x, y + 10);
}

function updateAttack(u, ux, uy, dt) {
    u.timer = (u.timer || 0) + dt;
    if (u.timer > (800 - u.grade*100) && monsters.length > 0) {
        let target = null;
        for(let m of monsters) {
            if(Math.hypot(m.x - ux, m.y - uy) < 180) { target = m; break; }
        }
        if (target) {
            u.timer = 0;
            ctx.strokeStyle = GRADES[u.grade].color; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(ux, uy); ctx.lineTo(target.x, target.y); ctx.stroke();
            target.hp -= GRADES[u.grade].power;
            if (target.hp <= 0) {
                gold += 2; createExplosion(target.x, target.y, '#ff4d4d');
                monsters.splice(monsters.indexOf(target), 1);
            }
        }
    }
}

// ğŸ› ï¸ í„°ì¹˜ ì¡°ì‘ ìµœì í™”
function getPointer(e) {
    const rect = canvas.getBoundingClientRect();
    const cx = e.touches ? e.touches[0].clientX : e.clientX;
    const cy = e.touches ? e.touches[0].clientY : e.clientY;
    return { x: cx - rect.left, y: cy - rect.top };
}

function handleStart(e) {
    const p = getPointer(e); mx = p.x; my = p.y;
    if (my > canvas.height - 110) { spawnUnit(); return; }
    for (let i = 0; i < 16; i++) {
        const bx = BOARD_X + (i % 4) * TILE_SIZE, by = BOARD_Y + Math.floor(i / 4) * TILE_SIZE;
        if (mx > bx && mx < bx + TILE_SIZE && my > by && my < by + TILE_SIZE) {
            if (board[i]) dragIdx = i;
        }
    }
}

function handleMove(e) { const p = getPointer(e); mx = p.x; my = p.y; }

function handleEnd() {
    if (dragIdx === null) return;
    let targetIdx = -1;
    for (let i = 0; i < 16; i++) {
        const bx = BOARD_X + (i % 4) * TILE_SIZE, by = BOARD_Y + Math.floor(i / 4) * TILE_SIZE;
        if (mx > bx && mx < bx + TILE_SIZE && my > by && my < by + TILE_SIZE) targetIdx = i;
    }

    if (targetIdx !== -1 && targetIdx !== dragIdx) {
        const a = board[dragIdx], b = board[targetIdx];
        if (b && a.name === b.name && a.grade === b.grade && a.grade < 3) {
            board[targetIdx] = { ...a, grade: a.grade + 1, timer: 0 };
            board[dragIdx] = null;
            createExplosion(mx, my, GRADES[a.grade+1].color);
        } else {
            board[dragIdx] = b; board[targetIdx] = a;
        }
    }
    dragIdx = null;
}

function spawnUnit() {
    const empty = board.map((v, i) => v === null ? i : null).filter(v => v !== null);
    if (empty.length > 0 && gold >= 10) {
        gold -= 10;
        const idx = empty[Math.floor(Math.random() * empty.length)];
        board[idx] = { name: UNIT_NAMES[Math.floor(Math.random()*4)], grade: 0, timer: 0 };
    }
}

function createExplosion(x, y, color) {
    for(let i=0; i<15; i++) particles.push({ x, y, color, vx:(Math.random()-0.5)*10, vy:(Math.random()-0.5)*10, life:1 });
}
function updateParticles() {
    particles.forEach(p => {
        p.x += p.vx; p.y += p.vy; p.life -= 0.04;
        ctx.fillStyle = p.color; ctx.globalAlpha = p.life;
        ctx.fillRect(p.x, p.y, 3, 3);
    });
    particles = particles.filter(p => p.life > 0); ctx.globalAlpha = 1;
}

function endGame() {
    gameState = 'OVER';
    document.getElementById('over-screen').classList.remove('hidden');
    document.getElementById('final-stats').innerText = `ìµœì¢… ì›¨ì´ë¸Œ: ${wave} | ê³¨ë“œ íšë“: ${gold}`;
}

canvas.addEventListener('mousedown', handleStart);
window.addEventListener('mousemove', handleMove);
window.addEventListener('mouseup', handleEnd);
canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleStart(e); }, {passive:false});
window.addEventListener('touchmove', (e) => { e.preventDefault(); handleMove(e); }, {passive:false});
window.addEventListener('touchend', handleEnd);
</script>
</body>
</html>
