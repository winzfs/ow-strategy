<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ì˜¤ë²„ì›Œì¹˜ ì „ëµ ë³´ë“œ Pro</title>
    <style>
        :root { --sidebar-width: 260px; --accent-color: #ff9c00; --ally-color: #00a2ff; --enemy-color: #ff3c3c; }
        body { margin: 0; display: flex; height: 100vh; overflow: hidden; font-family: 'Pretendard', sans-serif; background: #121212; color: white; touch-action: none; }
        
        /* ì‚¬ì´ë“œë°” ë° ë ˆì´ì•„ì›ƒ */
        #sidebar { width: var(--sidebar-width); background: #252525; overflow-y: auto; padding: 15px; border-right: 1px solid #444; z-index: 100; transition: 0.3s; }
        #sidebar.hidden { transform: translateX(-100%); position: absolute; height: 100%; }
        
        /* ì»¨íŠ¸ë¡¤ UI */
        .controls { position: absolute; right: 15px; top: 15px; z-index: 101; display: flex; flex-direction: column; gap: 8px; }
        .tool-group { background: rgba(0,0,0,0.7); padding: 8px; border-radius: 8px; display: flex; flex-direction: column; gap: 5px; }
        .tool-btn { background: #333; color: white; border: 1px solid #555; padding: 12px; cursor: pointer; border-radius: 6px; font-weight: bold; transition: 0.2s; }
        .tool-btn.active { border-color: white; transform: scale(1.05); }
        .btn-ally { color: var(--ally-color); } .btn-ally.active { background: var(--ally-color); color: white; }
        .btn-enemy { color: var(--enemy-color); } .btn-enemy.active { background: var(--enemy-color); color: white; }

        /* ì˜ì›… ë¦¬ìŠ¤íŠ¸ */
        .hero-list { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; margin-bottom: 20px; }
        .hero-item { aspect-ratio: 1/1; background: #333; border-radius: 4px; overflow: hidden; cursor: pointer; position: relative; border: 2px solid transparent; }
        .hero-item img { width: 100%; height: 100%; object-fit: cover; }
        .hero-item span { position: absolute; bottom: 0; width: 100%; font-size: 9px; background: rgba(0,0,0,0.7); text-align: center; white-space: nowrap; }

        /* ë©”ì¸ ë·°í¬íŠ¸ */
        #viewport { flex-grow: 1; position: relative; overflow: hidden; background: #000; cursor: grab; }
        #viewport.drawing-mode { cursor: crosshair; }
        #map-container { position: absolute; transform-origin: 0 0; }
        #map-image { display: block; user-select: none; -webkit-user-drag: none; }
        
        canvas { position: absolute; top: 0; left: 0; pointer-events: none; }
        #drawing-canvas { z-index: 20; } /* ì˜ì›…ë³´ë‹¤ ìœ„ì— ê·¸ë¦¬ê¸° */
        #temp-canvas { z-index: 21; }

        /* ë°°ì¹˜ëœ ì˜ì›… */
        .placed-hero { position: absolute; width: 50px; height: 50px; cursor: move; z-index: 10; transform: translate(-50%, -50%); border-radius: 50%; background: #222; overflow: hidden; border: 3px solid white; transition: box-shadow 0.2s; }
        .placed-hero.selected { box-shadow: 0 0 15px white; border-color: #fff !important; z-index: 11; }
        .placed-hero img { width: 100%; height: 100%; object-fit: cover; pointer-events: none; }
        .hero-delete-btn { position: absolute; top: -10px; right: -10px; background: red; color: white; border-radius: 50%; width: 20px; height: 20px; font-size: 12px; border: none; cursor: pointer; display: none; z-index: 12; }
        .selected .hero-delete-btn { display: block; }

        #toggle-btn { position: absolute; left: 15px; top: 15px; z-index: 101; padding: 10px 15px; background: var(--accent-color); border: none; border-radius: 6px; font-weight: bold; cursor: pointer; }
    </style>
</head>
<body>

<button id="toggle-btn">ì˜ì›… ì„ íƒ</button>

<div class="controls">
    <div class="tool-group">
        <button class="tool-btn active" id="btn-move">âœ‹ ì´ë™</button>
    </div>
    <div class="tool-group">
        <button class="tool-btn btn-ally" id="btn-pen-ally">ğŸ”µ ì•„êµ° íœ</button>
        <button class="tool-btn btn-enemy" id="btn-pen-enemy">ğŸ”´ ì êµ° íœ</button>
        <button class="tool-btn" id="btn-arrow">ğŸ¹ í™”ì‚´í‘œ</button>
    </div>
    <div class="tool-group">
        <button class="tool-btn" id="btn-undo">â†©ï¸ ì‹¤í–‰ ì·¨ì†Œ</button>
        <button class="tool-btn" id="btn-clear" style="color: #ff4444;">ğŸ—‘ï¸ ì „ì²´ ì‚­ì œ</button>
    </div>
</div>

<div id="sidebar">
    <div style="height: 50px;"></div>
    <div id="hero-categories"></div>
</div>

<div id="viewport">
    <div id="map-container">
        <img id="map-image" src="Lijiang_Tower_Top_Down_View.jpg">
        <div id="hero-layer"></div>
        <canvas id="drawing-canvas"></canvas>
        <canvas id="temp-canvas"></canvas>
    </div>
</div>

<script>
    const viewport = document.getElementById('viewport');
    const mapContainer = document.getElementById('map-container');
    const heroLayer = document.getElementById('hero-layer');
    const canvas = document.getElementById('drawing-canvas');
    const tempCanvas = document.getElementById('temp-canvas');
    const ctx = canvas.getContext('2d');
    const tctx = tempCanvas.getContext('2d');
    const mapImg = document.getElementById('map-image');

    let scale = 0.5, translateX = 0, translateY = 0;
    let isDragging = false, startX, startY;
    let currentTool = 'move';
    let currentColor = 'var(--ally-color)';
    let isDrawing = false, drawStartPos = null;
    let history = [];
    let selectedHero = null;

    // 1. ê³ í•´ìƒë„ ì„¤ì • ë° ì´ˆê¸°í™”
    mapImg.onload = () => {
        const dpr = window.devicePixelRatio || 1;
        const width = mapImg.naturalWidth;
        const height = mapImg.naturalHeight;
        
        canvas.width = tempCanvas.width = width * dpr;
        canvas.height = tempCanvas.height = height * dpr;
        canvas.style.width = tempCanvas.style.width = width + 'px';
        canvas.style.height = tempCanvas.style.height = height + 'px';
        
        ctx.scale(dpr, dpr);
        tctx.scale(dpr, dpr);
        
        saveState();
        update();
    };

    function saveState() {
        history.push(canvas.toDataURL());
        if (history.length > 30) history.shift();
    }

    function undo() {
        if (history.length <= 1) return;
        history.pop();
        const img = new Image();
        img.src = history[history.length - 1];
        img.onload = () => {
            const dpr = window.devicePixelRatio || 1;
            ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
            ctx.drawImage(img, 0, 0, canvas.width / dpr, canvas.height / dpr);
        };
    }

    // 2. ë„êµ¬ ì œì–´
    document.querySelectorAll('.tool-btn').forEach(btn => {
        btn.onclick = () => {
            if (btn.id === 'btn-clear') { if(confirm('ëª¨ë‘ ì§€ìš¸ê¹Œìš”?')) { ctx.clearRect(0,0,canvas.width,canvas.height); heroLayer.innerHTML=''; saveState(); } return; }
            if (btn.id === 'btn-undo') { undo(); return; }
            
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            
            if (btn.id.includes('ally')) currentColor = '#00a2ff';
            if (btn.id.includes('enemy')) currentColor = '#ff3c3c';
            
            currentTool = btn.id.replace('btn-', '').split('-')[0];
            viewport.className = (currentTool === 'move') ? '' : 'drawing-mode';
        };
    });

    const getPos = (e) => {
        const rect = viewport.getBoundingClientRect();
        const cx = e.touches ? e.touches[0].clientX : e.clientX;
        const cy = e.touches ? e.touches[0].clientY : e.clientY;
        return { 
            x: (cx - rect.left - translateX) / scale, 
            y: (cy - rect.top - translateY) / scale 
        };
    };

    // 3. ë“œë¡œì‰ ë¡œì§ (ê³ í•´ìƒë„ íœ & í™”ì‚´í‘œ)
    const handleStart = (e) => {
        if (currentTool === 'move') {
            if (e.target === viewport || e.target === mapImg) {
                isDragging = true;
                const cx = e.touches ? e.touches[0].clientX : e.clientX;
                const cy = e.touches ? e.touches[0].clientY : e.clientY;
                startX = cx - translateX; startY = cy - translateY;
                if(selectedHero) { selectedHero.classList.remove('selected'); selectedHero = null; }
            }
            return;
        }
        isDrawing = true;
        drawStartPos = getPos(e);
        ctx.strokeStyle = tctx.strokeStyle = currentColor;
        ctx.lineWidth = tctx.lineWidth = 5 / scale;
        ctx.lineCap = ctx.lineJoin = 'round';
        if (currentTool === 'pen') {
            ctx.beginPath();
            ctx.moveTo(drawStartPos.x, drawStartPos.y);
        }
    };

    const handleMove = (e) => {
        if (isDragging) {
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            translateX = cx - startX; translateY = cy - startY;
            update(); return;
        }
        if (!isDrawing) return;
        const p = getPos(e);
        if (currentTool === 'pen') {
            ctx.lineTo(p.x, p.y); ctx.stroke();
        } else if (currentTool === 'arrow') {
            tctx.clearRect(0, 0, mapImg.naturalWidth, mapImg.naturalHeight);
            drawArrow(tctx, drawStartPos.x, drawStartPos.y, p.x, p.y);
        }
    };

    const handleEnd = (e) => {
        if (isDrawing) {
            if (currentTool === 'arrow') {
                const p = getPos(e.changedTouches ? e.changedTouches[0] : e);
                drawArrow(ctx, drawStartPos.x, drawStartPos.y, p.x, p.y);
            }
            tctx.clearRect(0, 0, mapImg.naturalWidth, mapImg.naturalHeight);
            isDrawing = false; saveState();
        }
        isDragging = false;
    };

    function drawArrow(t, fx, fy, tx, ty) {
        const headlen = 20 / scale;
        const angle = Math.atan2(ty - fy, tx - fx);
        t.beginPath();
        t.moveTo(fx, fy); t.lineTo(tx, ty);
        t.lineTo(tx - headlen * Math.cos(angle - Math.PI / 6), ty - headlen * Math.sin(angle - Math.PI / 6));
        t.moveTo(tx, ty);
        t.lineTo(tx - headlen * Math.cos(angle + Math.PI / 6), ty - headlen * Math.sin(angle + Math.PI / 6));
        t.stroke();
    }

    // 4. ì˜ì›… ê´€ë¦¬ ì‹œìŠ¤í…œ
    const heroes = {
        "ëŒê²© (TANK)": ["dva", "doomfist", "ramattra", "reinhardt", "wrecking-ball", "roadhog", "mauga", "sigma", "winston", "zarya", "junker-queen"],
        "ê³µê²© (DPS)": ["genji", "reaper", "mei", "bastion", "sojourn", "soldier-76", "sombra", "symmetra", "ashe", "echo", "widowmaker", "junkrat", "cassidy", "torbjorn", "tracer", "pharah", "venture"],
        "ì§€ì› (SUP)": ["lifeweaver", "lucio", "baptiste", "brigitte", "ana", "illari", "zenyatta", "kiriko", "moira"]
    };

    const categoryContainer = document.getElementById('hero-categories');
    Object.entries(heroes).forEach(([role, list]) => {
        const catDiv = document.createElement('div');
        catDiv.className = 'category';
        catDiv.innerHTML = `<h3 style="font-size:12px; color:var(--accent-color); border-bottom:1px solid #444;">${role}</h3><div class="hero-list"></div>`;
        const listDiv = catDiv.querySelector('.hero-list');
        list.forEach(id => {
            const item = document.createElement('div');
            item.className = 'hero-item';
            item.innerHTML = `<img src="https://d1u1mce87gyfbn.cloudfront.net/hero/${id}/icon-portrait.png">`;
            item.onclick = () => {
                const rx = (viewport.offsetWidth / 2 - translateX) / scale / mapImg.naturalWidth;
                const ry = (viewport.offsetHeight / 2 - translateY) / scale / mapImg.naturalHeight;
                createHero(id, rx, ry);
            };
            listDiv.appendChild(item);
        });
        categoryContainer.appendChild(catDiv);
    });

    function createHero(id, rx, ry) {
        const div = document.createElement('div');
        div.className = 'placed-hero';
        div.style.borderColor = currentColor; // í˜„ì¬ ì„ íƒëœ íŒ€ ìƒ‰ìƒ ì ìš©
        
        // ì •ë°€ ì¢Œí‘œ (ë¹„ìœ¨ ê¸°ë°˜ ì €ì¥)
        const updatePos = (x, y) => {
            div.dataset.rx = x / mapImg.naturalWidth;
            div.dataset.ry = y / mapImg.naturalHeight;
            div.style.left = x + 'px';
            div.style.top = y + 'px';
        };
        updatePos(rx * mapImg.naturalWidth, ry * mapImg.naturalHeight);

        div.innerHTML = `<img src="https://d1u1mce87gyfbn.cloudfront.net/hero/${id}/icon-portrait.png"><button class="hero-delete-btn">âœ•</button>`;
        
        // ì˜ì›… ë“œë˜ê·¸ ë¡œì§
        let hDrag = false, ox, oy;
        const hStart = (e) => {
            e.stopPropagation();
            if(selectedHero) selectedHero.classList.remove('selected');
            selectedHero = div;
            div.classList.add('selected');
            hDrag = true;
            const p = getPos(e);
            ox = p.x - parseFloat(div.style.left);
            oy = p.y - parseFloat(div.style.top);
        };

        div.onmousedown = hStart; div.ontouchstart = hStart;
        div.querySelector('.hero-delete-btn').onclick = (e) => { e.stopPropagation(); div.remove(); };
        div.oncontextmenu = (e) => { e.preventDefault(); div.remove(); };

        window.addEventListener('mousemove', (e) => {
            if (!hDrag) return;
            const p = getPos(e);
            updatePos(p.x - ox, p.y - oy);
        });
        window.addEventListener('mouseup', () => hDrag = false);
        window.addEventListener('touchend', () => hDrag = false);
        window.addEventListener('touchmove', (e) => { if(hDrag) { e.preventDefault(); const p = getPos(e); updatePos(p.x-ox, p.y-oy); }}, {passive:false});

        heroLayer.appendChild(div);
    }

     // 5. ë·°í¬íŠ¸ ì´ë²¤íŠ¸ ë°”ì¸ë”© // 5. ë·°í¬íŠ¸ ì´ë²¤íŠ¸ ë°”ì¸ë”©
    viewport.addEventListener('mousedown', handleStart);
    window.addEventListener('mousemove', handleMove);
    window.addEventListener('mouseup', handleEnd);
    viewport.addEventListener('touchstart', (e) => { if(e.touches.length === 1) handleStart(e); else isDragging=false; }, {passive:false});
    window.addEventListener('touchmove', (e) => { if(isDrawing || isDragging) { e.preventDefault(); handleMove(e); }}, {passive:false});
    window.addEventListener('touchend', handleEnd);

     // íœ  ì¤Œ // íœ  ì¤Œ
    viewport.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY < 0 ? 1.1 : 0.9;
        const rect = viewport.getBoundingClientRect();
        const mx = e.clientX - rect.left, my = e.clientY - rect.top;
        const gx = (mx - translateX) / scale, gy = (my - translateY) / scale;
        scale = Math.min(Math.max(0.1, scale * delta), 4);
        translateX = mx - gx * scale; translateY = my - gy * scale;
        update();
    }, {passive: false});

    function update() { 
        mapContainer.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`; 
    }

    document.getElementById('toggle-btn').onclick = () => document.getElementById('sidebar').classList.toggle('hidden');
</script>
</body>
</html>
