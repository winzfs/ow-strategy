<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ïò§Î≤ÑÏõåÏπò Ï†ÑÎûµ Î≥¥Îìú - ÏµúÏ¢Ö ÏàòÏ†ï (Î≤ÑÍ∑∏ ÌîΩÏä§)</title>
    <style>
        :root { --sidebar-width: 260px; --accent-color: #ff9c00; }
        body { margin: 0; display: flex; height: 100vh; overflow: hidden; font-family: sans-serif; background: #1a1a1a; color: white; touch-action: none; }
        
        #sidebar { width: var(--sidebar-width); background: #2d2d2d; overflow-y: auto; padding: 10px; border-right: 2px solid #444; transition: transform 0.3s ease; z-index: 100; }
        #sidebar.hidden { transform: translateX(-100%); position: absolute; height: 100%; }
        
        #toggle-btn { position: absolute; left: 10px; top: 10px; z-index: 101; background: var(--accent-color); border: none; color: black; font-weight: bold; padding: 8px 12px; cursor: pointer; border-radius: 4px; }
        .controls { position: absolute; right: 10px; top: 10px; z-index: 101; display: flex; flex-direction: column; gap: 5px; }
        .tool-btn { background: #333; color: white; border: 1px solid #666; padding: 10px; cursor: pointer; border-radius: 4px; font-size: 12px; }
        .tool-btn.active { background: var(--accent-color); color: black; border-color: white; }
        .history-controls { display: flex; gap: 5px; margin-top: 5px; }
        .history-btn { flex: 1; background: #555; border: none; color: white; padding: 5px; cursor: pointer; border-radius: 4px; font-size: 10px; }

        .category h3 { border-bottom: 1px solid #666; padding-bottom: 5px; color: var(--accent-color); font-size: 14px; margin-top: 20px; }
        .hero-list { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; }
        .hero-item { aspect-ratio: 1/1; background: #444; border-radius: 4px; overflow: hidden; cursor: pointer; border: 2px solid transparent; position: relative; }
        .hero-item img { width: 100%; height: 100%; object-fit: cover; pointer-events: none; }
        .hero-item span { position: absolute; bottom: 0; width: 100%; font-size: 8px; background: rgba(0,0,0,0.6); text-align: center; }

        #viewport { flex-grow: 1; position: relative; overflow: hidden; background: #000; }
        #map-container { position: absolute; transform-origin: 0 0; }
        #map-image { display: block; user-select: none; -webkit-user-drag: none; max-width: none; }
        
        canvas { position: absolute; top: 0; left: 0; pointer-events: none; }
        #drawing-canvas { z-index: 5; }
        #temp-canvas { z-index: 6; }
        
        /* Í∑∏Î¶¨Í∏∞ Î™®ÎìúÏùº ÎïåÎßå Î∑∞Ìè¨Ìä∏Í∞Ä Ïù¥Î≤§Ìä∏Î•º ÏßÅÏ†ë Î∞õÏùå */
        #viewport.drawing-mode { cursor: crosshair; }

        .placed-hero { position: absolute; width: 50px; height: 50px; cursor: move; z-index: 10; transform: translate(-50%, -50%); border: 3px solid var(--accent-color); border-radius: 50%; background: #333; overflow: hidden; touch-action: none; }
        .placed-hero img { width: 100%; height: 100%; object-fit: cover; pointer-events: none; }
    </style>
</head>
<body>

<button id="toggle-btn">MENU</button>

<div class="controls">
    <button class="tool-btn active" id="btn-move">‚úã Ïù¥Îèô/Î∞∞Ïπò</button>
    <button class="tool-btn" id="btn-pen">‚úèÔ∏è Ìéú</button>
    <button class="tool-btn" id="btn-arrow">üèπ ÌôîÏÇ¥Ìëú</button>
    <div class="history-controls">
        <button class="history-btn" id="btn-undo">‚Ü©Ô∏è Undo</button>
        <button class="history-btn" id="btn-redo">‚Ü™Ô∏è Redo</button>
    </div>
    <button class="tool-btn" id="btn-clear" style="background: #900; margin-top: 5px;">üóëÔ∏è Clear</button>
</div>

<div id="sidebar">
    <div style="height: 40px;"></div>
    <div id="hero-categories"></div>
</div>

<div id="viewport">
    <div id="map-container">
        <img id="map-image" src="Lijiang_Tower_Top_Down_View.jpg">
        <canvas id="drawing-canvas"></canvas>
        <canvas id="temp-canvas"></canvas>
    </div>
</div>

<script>
    const viewport = document.getElementById('viewport');
    const mapContainer = document.getElementById('map-container');
    const canvas = document.getElementById('drawing-canvas');
    const tempCanvas = document.getElementById('temp-canvas');
    const ctx = canvas.getContext('2d');
    const tctx = tempCanvas.getContext('2d');
    const mapImg = document.getElementById('map-image');

    let scale = 0.5, translateX = 0, translateY = 0;
    let isDragging = false, startX, startY;
    let currentTool = 'move';
    let isDrawing = false, drawStartPos = null;
    let history = [], redoStack = [];

    mapImg.onload = () => {
        canvas.width = tempCanvas.width = mapImg.naturalWidth;
        canvas.height = tempCanvas.height = mapImg.naturalHeight;
        saveState();
        update();
    };

    function saveState() {
        history.push(canvas.toDataURL());
        if (history.length > 40) history.shift();
        redoStack = []; 
    }

    function undo() {
        if (history.length <= 1) return;
        redoStack.push(history.pop());
        const img = new Image();
        img.src = history[history.length - 1];
        img.onload = () => { ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.drawImage(img, 0, 0); };
    }

    function redo() {
        if (redoStack.length === 0) return;
        const state = redoStack.pop();
        history.push(state);
        const img = new Image();
        img.src = state;
        img.onload = () => { ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.drawImage(img, 0, 0); };
    }

    // ÎèÑÍµ¨ Ï†ÑÌôò
    document.querySelectorAll('.tool-btn, .history-btn').forEach(btn => {
        btn.onclick = () => {
            if (btn.id === 'btn-clear') { if(confirm('Î™®Îì† Í∑∏Î¶ºÏùÑ ÏßÄÏö∏ÍπåÏöî?')) { ctx.clearRect(0, 0, canvas.width, canvas.height); saveState(); } return; }
            if (btn.id === 'btn-undo') { undo(); return; }
            if (btn.id === 'btn-redo') { redo(); return; }
            
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            currentTool = btn.id.replace('btn-', '');
            viewport.className = (currentTool === 'move') ? '' : 'drawing-mode';
        };
    });

    const getPos = (e) => {
        const rect = viewport.getBoundingClientRect();
        const cx = e.touches ? e.touches[0].clientX : e.clientX;
        const cy = e.touches ? e.touches[0].clientY : e.clientY;
        return { x: (cx - rect.left - translateX) / scale, y: (cy - rect.top - translateY) / scale };
    };

    // ÌÜµÌï© Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨
    const handleStart = (e) => {
        if (currentTool === 'move') {
            if (!e.touches || e.touches.length === 1) {
                isDragging = true;
                const cx = e.touches ? e.touches[0].clientX : e.clientX;
                const cy = e.touches ? e.touches[0].clientY : e.clientY;
                startX = cx - translateX;
                startY = cy - translateY;
            }
            return;
        }
        // Í∑∏Î¶¨Í∏∞ Î™®Îìú
        isDrawing = true;
        drawStartPos = getPos(e);
        if (currentTool === 'pen') {
            ctx.beginPath();
            ctx.moveTo(drawStartPos.x, drawStartPos.y);
            ctx.strokeStyle = '#ff9c00';
            ctx.lineWidth = 6 / scale;
            ctx.lineCap = ctx.lineJoin = 'round';
        }
    };

    const handleMove = (e) => {
        if (isDragging && currentTool === 'move') {
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            translateX = cx - startX;
            translateY = cy - startY;
            update();
            return;
        }
        if (!isDrawing) return;
        const p = getPos(e);
        if (currentTool === 'pen') {
            ctx.lineTo(p.x, p.y);
            ctx.stroke();
        } else if (currentTool === 'arrow') {
            tctx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
            drawArrow(tctx, drawStartPos.x, drawStartPos.y, p.x, p.y);
        }
    };

    const handleEnd = () => {
        if (isDrawing) {
            if (currentTool === 'arrow' && drawStartPos) {
                // ÎßàÏßÄÎßâ ÏúÑÏπòÎ•º ÏïåÏïÑÎÇ¥Í∏∞ ÏúÑÌï¥ Î≥ÑÎèÑ Ï†ÄÏû•ÌïòÏßÄ ÏïäÍ≥† tctx ÎÇ¥Ïö©ÏùÑ Í∑∏Î¶¨Í±∞ÎÇò Ïû¨Í≥ÑÏÇ∞
                // Ïó¨Í∏∞ÏÑúÎäî ÎßàÏßÄÎßâ ÎßàÏö∞Ïä§ ÏúÑÏπò Í∏∞Î∞òÏúºÎ°ú drawArrowÎ•º ctxÏóê Ìïú Î≤à Îçî ÏàòÌñâ
            }
            tctx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
            isDrawing = false;
            saveState();
        }
        isDragging = false;
        lastDist = 0;
    };

    // ÌôîÏÇ¥Ìëú Í∑∏Î¶¨Í∏∞ Ìï®Ïàò (ctx ÏßÄÏ†ï Í∞ÄÎä•)
    function drawArrow(targetCtx, fx, fy, tx, ty) {
        const headlen = 25 / scale;
        const angle = Math.atan2(ty - fy, tx - fx);
        targetCtx.beginPath();
        targetCtx.strokeStyle = '#ff9c00';
        targetCtx.lineWidth = 6 / scale;
        targetCtx.lineCap = targetCtx.lineJoin = 'round';
        targetCtx.moveTo(fx, fy);
        targetCtx.lineTo(tx, ty);
        targetCtx.lineTo(tx - headlen * Math.cos(angle - Math.PI / 6), ty - headlen * Math.sin(angle - Math.PI / 6));
        targetCtx.moveTo(tx, ty);
        targetCtx.lineTo(tx - headlen * Math.cos(angle + Math.PI / 6), ty - headlen * Math.sin(angle + Math.PI / 6));
        targetCtx.stroke();
    }

    // ÎßàÏö∞Ïä§ Î∞è ÌÑ∞Ïπò Î¶¨Ïä§ÎÑà
    viewport.addEventListener('mousedown', handleStart);
    window.addEventListener('mousemove', handleMove);
    window.addEventListener('mouseup', (e) => {
        if (isDrawing && currentTool === 'arrow') {
            const p = getPos(e);
            drawArrow(ctx, drawStartPos.x, drawStartPos.y, p.x, p.y);
        }
        handleEnd();
    });

    viewport.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
            lastDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
            return;
        }
        handleStart(e);
    }, {passive: false});

    window.addEventListener('touchmove', (e) => {
        if (e.touches.length === 2) {
            const dist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
            if (lastDist > 0) {
                const rect = viewport.getBoundingClientRect();
                const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left;
                const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top;
                const gx = (midX - translateX) / scale, gy = (midY - translateY) / scale;
                scale = Math.min(Math.max(0.1, scale * (dist / lastDist)), 4);
                translateX = midX - gx * scale; translateY = midY - gy * scale;
                update();
            }
            lastDist = dist;
            return;
        }
        if (isDrawing || isDragging) { e.preventDefault(); handleMove(e); }
    }, {passive: false});

    window.addEventListener('touchend', (e) => {
        if (isDrawing && currentTool === 'arrow') {
            const p = getPos(e.changedTouches[0]);
            drawArrow(ctx, drawStartPos.x, drawStartPos.y, p.x, p.y);
        }
        handleEnd();
    });

    // Ìú† ÌôïÎåÄ Ï∂ïÏÜå
    viewport.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY < 0 ? 1.1 : 0.9;
        const rect = viewport.getBoundingClientRect();
        const mx = e.clientX - rect.left, my = e.clientY - rect.top;
        const gx = (mx - translateX) / scale, gy = (my - translateY) / scale;
        scale = Math.min(Math.max(0.1, scale * delta), 4);
        translateX = mx - gx * scale; translateY = my - gy * scale;
        update();
    }, {passive: false});

    function update() { 
        mapContainer.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`; 
    }

    // ÏòÅÏõÖ Îç∞Ïù¥ÌÑ∞ Î°úÏßÅ (ÏÉùÎûµ ÏóÜÏù¥ Ìè¨Ìï®)
    const heroes = {
        "ÎèåÍ≤© (TANK)": [{id: "dva", name: "ÎîîÎ∞î"}, {id: "doomfist", name: "Îë†Ìîº"}, {id: "ramattra", name: "ÎùºÎßõ"}, {id: "reinhardt", name: "ÎùºÏù∏"}, {id: "wrecking-ball", name: "Î†àÌÇπ"}, {id: "roadhog", name: "Ìò∏Í∑∏"}, {id: "mauga", name: "ÎßàÏö∞Í∞Ä"}, {id: "sigma", name: "ÏãúÍ∑∏Îßà"}, {id: "winston", name: "ÏúàÏä§ÌÑ¥"}, {id: "zarya", name: "ÏûêÎ¶¨Ïïº"}, {id: "junker-queen", name: "Ï†ïÏª§ÌÄ∏"}],
        "Í≥µÍ≤© (DPS)": [{id: "genji", name: "Í≤êÏßÄ"}, {id: "reaper", name: "Î¶¨Ìçº"}, {id: "mei", name: "Î©îÏù¥"}, {id: "bastion", name: "Î∞îÏä§"}, {id: "sojourn", name: "ÏÜåÏ†Ñ"}, {id: "soldier-76", name: "ÏÜîÏ†Ä"}, {id: "sombra", name: "ÏÜúÎ∏åÎùº"}, {id: "symmetra", name: "ÏãúÎ©î"}, {id: "ashe", name: "Ïï†Ïâ¨"}, {id: "echo", name: "ÏóêÏΩî"}, {id: "widowmaker", name: "ÏúÑÎèÑÏö∞"}, {id: "junkrat", name: "Ï†ïÎû´"}, {id: "cassidy", name: "Ï∫êÏãúÎîî"}, {id: "torbjorn", name: "ÌÜ†Î∏å"}, {id: "tracer", name: "Ìä∏Î†à"}, {id: "pharah", name: "ÌååÎùº"}, {id: "venture", name: "Î≤§Ï≤ò"}],
        "ÏßÄÏõê (SUP)": [{id: "lifeweaver", name: "ÎùºÏúÑ"}, {id: "lucio", name: "Î£®ÏãúÏö∞"}, {id: "baptiste", name: "Î∞îÌã∞"}, {id: "brigitte", name: "Î∏åÎ¶¨Í∏∞"}, {id: "ana", name: "ÏïÑÎÇò"}, {id: "illari", name: "ÏùºÎ¶¨Î¶¨"}, {id: "zenyatta", name: "Ï††ÏïºÌÉÄ"}, {id: "kiriko", name: "ÌÇ§Î¶¨ÏΩî"}, {id: "moira", name: "Î™®Ïù¥Îùº"}]
    };

    const categoryContainer = document.getElementById('hero-categories');
    Object.entries(heroes).forEach(([role, list]) => {
        const catDiv = document.createElement('div');
        catDiv.className = 'category';
        catDiv.innerHTML = `<h3>${role}</h3><div class="hero-list"></div>`;
        const listDiv = catDiv.querySelector('.hero-list');
        list.forEach(hero => {
            const item = document.createElement('div');
            item.className = 'hero-item';
            const imgUrl = `https://d1u1mce87gyfbn.cloudfront.net/hero/${hero.id}/icon-portrait.png`;
            item.innerHTML = `<img src="${imgUrl}" onerror="this.src='https://via.placeholder.com/50?text=${hero.id}'"><span>${hero.name}</span>`;
            item.onclick = () => {
                const centerX = (viewport.offsetWidth / 2 - translateX) / scale;
                const centerY = (viewport.offsetHeight / 2 - translateY) / scale;
                createHeroOnMap(hero, centerX, centerY);
            };
            listDiv.appendChild(item);
        });
        categoryContainer.appendChild(catDiv);
    });

    function createHeroOnMap(hero, x, y) {
        const div = document.createElement('div');
        div.className = 'placed-hero';
        div.style.left = `${x}px`; div.style.top = `${y}px`;
        div.innerHTML = `<img src="https://d1u1mce87gyfbn.cloudfront.net/hero/${hero.id}/icon-portrait.png">`;
        let heroDrag = false;
        let hStartX, hStartY;
        const hStart = (e) => {
            e.stopPropagation();
            heroDrag = true;
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            hStartX = (cx - translateX) / scale - parseFloat(div.style.left);
            hStartY = (cy - translateY) / scale - parseFloat(div.style.top);
        };
        div.onmousedown = hStart; div.ontouchstart = hStart;
        const hMove = (e) => {
            if (!heroDrag) return;
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            div.style.left = `${(cx - translateX) / scale - hStartX}px`;
            div.style.top = `${(cy - translateY) / scale - hStartY}px`;
        };
        window.addEventListener('mousemove', hMove);
        window.addEventListener('touchmove', hMove);
        window.addEventListener('mouseup', () => heroDrag = false);
        window.addEventListener('touchend', () => heroDrag = false);
        div.oncontextmenu = (e) => { e.preventDefault(); div.remove(); };
        mapContainer.appendChild(div);
    }
    
    document.getElementById('toggle-btn').onclick = () => document.getElementById('sidebar').classList.toggle('hidden');
</script>
</body>
</html>
